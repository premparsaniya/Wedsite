import{B as h,L as l,o as b,E as _,a as y,G as O,H as T}from"./web3.min-cf08a409.js";const a=new l(T),u={},S=h.from(0),U=h.from(-1);function A(o,t,r,i){const n={fault:t,operation:r};return i!==void 0&&(n.value=i),a.throwError(o,l.errors.NUMERIC_FAULT,n)}let g="0";for(;g.length<256;)g+=g;function E(o){if(typeof o!="number")try{o=h.from(o).toNumber()}catch{}return typeof o=="number"&&o>=0&&o<=256&&!(o%1)?"1"+g.substring(0,o):a.throwArgumentError("invalid decimal size","decimals",o)}function w(o,t){t==null&&(t=0);const r=E(t);o=h.from(o);const i=o.lt(S);i&&(o=o.mul(U));let n=o.mod(r).toString();for(;n.length<r.length-1;)n="0"+n;n=n.match(/^([0-9]*[1-9]|0)(0*)/)[1];const s=o.div(r).toString();return r.length===1?o=s:o=s+"."+n,i&&(o="-"+o),o}function m(o,t){t==null&&(t=0);const r=E(t);(typeof o!="string"||!o.match(/^-?[0-9.]+$/))&&a.throwArgumentError("invalid decimal value","value",o);const i=o.substring(0,1)==="-";i&&(o=o.substring(1)),o==="."&&a.throwArgumentError("missing value","value",o);const n=o.split(".");n.length>2&&a.throwArgumentError("too many decimal points","value",o);let s=n[0],e=n[1];for(s||(s="0"),e||(e="0");e[e.length-1]==="0";)e=e.substring(0,e.length-1);for(e.length>r.length-1&&A("fractional component exceeds decimals","underflow","parseFixed"),e===""&&(e="0");e.length<r.length-1;)e+="0";const d=h.from(s),p=h.from(e);let x=d.mul(r).add(p);return i&&(x=x.mul(U)),x}class c{constructor(t,r,i,n){t!==u&&a.throwError("cannot use FixedFormat constructor; use FixedFormat.from",l.errors.UNSUPPORTED_OPERATION,{operation:"new FixedFormat"}),this.signed=r,this.width=i,this.decimals=n,this.name=(r?"":"u")+"fixed"+String(i)+"x"+String(n),this._multiplier=E(n),Object.freeze(this)}static from(t){if(t instanceof c)return t;typeof t=="number"&&(t=`fixed128x${t}`);let r=!0,i=128,n=18;if(typeof t=="string"){if(t!=="fixed")if(t==="ufixed")r=!1;else{const s=t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);s||a.throwArgumentError("invalid fixed format","format",t),r=s[1]!=="u",i=parseInt(s[2]),n=parseInt(s[3])}}else if(t){const s=(e,d,p)=>t[e]==null?p:(typeof t[e]!==d&&a.throwArgumentError("invalid fixed format ("+e+" not "+d+")","format."+e,t[e]),t[e]);r=s("signed","boolean",r),i=s("width","number",i),n=s("decimals","number",n)}return i%8&&a.throwArgumentError("invalid fixed format width (not byte aligned)","format.width",i),n>80&&a.throwArgumentError("invalid fixed format (decimals too large)","format.decimals",n),new c(u,r,i,n)}}class f{constructor(t,r,i,n){t!==u&&a.throwError("cannot use FixedNumber constructor; use FixedNumber.from",l.errors.UNSUPPORTED_OPERATION,{operation:"new FixedFormat"}),this.format=n,this._hex=r,this._value=i,this._isFixedNumber=!0,Object.freeze(this)}_checkFormat(t){this.format.name!==t.format.name&&a.throwArgumentError("incompatible format; use fixedNumber.toFormat","other",t)}addUnsafe(t){this._checkFormat(t);const r=m(this._value,this.format.decimals),i=m(t._value,t.format.decimals);return f.fromValue(r.add(i),this.format.decimals,this.format)}subUnsafe(t){this._checkFormat(t);const r=m(this._value,this.format.decimals),i=m(t._value,t.format.decimals);return f.fromValue(r.sub(i),this.format.decimals,this.format)}mulUnsafe(t){this._checkFormat(t);const r=m(this._value,this.format.decimals),i=m(t._value,t.format.decimals);return f.fromValue(r.mul(i).div(this.format._multiplier),this.format.decimals,this.format)}divUnsafe(t){this._checkFormat(t);const r=m(this._value,this.format.decimals),i=m(t._value,t.format.decimals);return f.fromValue(r.mul(this.format._multiplier).div(i),this.format.decimals,this.format)}floor(){const t=this.toString().split(".");t.length===1&&t.push("0");let r=f.from(t[0],this.format);const i=!t[1].match(/^(0*)$/);return this.isNegative()&&i&&(r=r.subUnsafe(F.toFormat(r.format))),r}ceiling(){const t=this.toString().split(".");t.length===1&&t.push("0");let r=f.from(t[0],this.format);const i=!t[1].match(/^(0*)$/);return!this.isNegative()&&i&&(r=r.addUnsafe(F.toFormat(r.format))),r}round(t){t==null&&(t=0);const r=this.toString().split(".");if(r.length===1&&r.push("0"),(t<0||t>80||t%1)&&a.throwArgumentError("invalid decimal count","decimals",t),r[1].length<=t)return this;const i=f.from("1"+g.substring(0,t),this.format),n=V.toFormat(this.format);return this.mulUnsafe(i).addUnsafe(n).floor().divUnsafe(i)}isZero(){return this._value==="0.0"||this._value==="0"}isNegative(){return this._value[0]==="-"}toString(){return this._value}toHexString(t){if(t==null)return this._hex;t%8&&a.throwArgumentError("invalid byte width","width",t);const r=h.from(this._hex).fromTwos(this.format.width).toTwos(t).toHexString();return b(r,t/8)}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(t){return f.fromString(this._value,t)}static fromValue(t,r,i){return i==null&&r!=null&&!_(r)&&(i=r,r=null),r==null&&(r=0),i==null&&(i="fixed"),f.fromString(w(t,r),c.from(i))}static fromString(t,r){r==null&&(r="fixed");const i=c.from(r),n=m(t,i.decimals);!i.signed&&n.lt(S)&&A("unsigned value cannot be negative","overflow","value",t);let s=null;i.signed?s=n.toTwos(i.width).toHexString():(s=n.toHexString(),s=b(s,i.width/8));const e=w(n,i.decimals);return new f(u,s,e,i)}static fromBytes(t,r){r==null&&(r="fixed");const i=c.from(r);if(y(t).length>i.width/8)throw new Error("overflow");let n=h.from(t);i.signed&&(n=n.fromTwos(i.width));const s=n.toTwos((i.signed?0:1)+i.width).toHexString(),e=w(n,i.decimals);return new f(u,s,e,i)}static from(t,r){if(typeof t=="string")return f.fromString(t,r);if(O(t))return f.fromBytes(t,r);try{return f.fromValue(t,0,r)}catch(i){if(i.code!==l.errors.INVALID_ARGUMENT)throw i}return a.throwArgumentError("invalid FixedNumber value","value",t)}static isFixedNumber(t){return!!(t&&t._isFixedNumber)}}const F=f.from(1),V=f.from("0.5"),P="units/5.7.0";new l(P);const B=["wei","kwei","mwei","gwei","szabo","finney","ether"];function I(o,t){if(typeof t=="string"){const r=B.indexOf(t);r!==-1&&(t=3*r)}return w(o,t??18)}function H(o){return I(o,18)}export{H as f};
//# sourceMappingURL=index-9f68e806.js.map
